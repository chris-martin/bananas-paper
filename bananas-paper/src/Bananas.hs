{-# LANGUAGE NoImplicitPrelude, LambdaCase,
RecordWildCards, DuplicateRecordFields #-}

module Bananas
  (

  -- * Anamorphism
  -- $anamorphism
    Anamorphism (..)
  , anamorphismFunction
  , untilAnamorphism

  -- * Catamorphism
  -- $catamorphism
  , Catamorphism (..)
  , catamorphismFunction
  , productCatamorphism

  -- * Hylomorphism
  -- $hylomorphism
  , Hylomorphism
  , hylomorphismFunction
  , hylomorphismFunction'
  , factorialHylomorphism

  -- * Number paramorphism
  , NumberParamorphism (..)
  , numberParamorphismFunction
  , factorialParamorphism

  -- * List paramorphism
  , ListParamorphism (..)
  , listParamorphismFunction
  , tailsParamorphism

  ) where

import Numeric.Natural (Natural)
import Prelude (Maybe (..), Num (..), Integer, (.), Eq(..), Bool (..))


--------------------------------------------------------------------------------

{- $anamorphism

The prefix "ana-" is from Greek, meaning "upward". The tenuous analogy is that
an anamorphism is "builds up" a list.

-}

{- | An anamorphism, starting from an initial value of type @a@ produces a list
of @b@. -}

data Anamorphism a b =
  Anamorphism
    { generate :: a -> Maybe (b, a)
    }

{- | Convert an anamorphism to a function. -}

anamorphismFunction :: Anamorphism a b -> (a -> [b])
anamorphismFunction Anamorphism{..} =
  go
  where
    go a =
      case generate a of
        Just (b, a') -> b : go a'
        Nothing      -> []

untilAnamorphism :: (a -> Bool) -> (a -> a) -> Anamorphism a a
untilAnamorphism stop next =
  Anamorphism
    { generate = \x -> if stop x then Nothing else Just (x, next x)
    }

--------------------------------------------------------------------------------

{- $catamorphism

The prefix "cata-" is from Greek, meaning "downward". The tenuous analogy is
that a catamorphism "tears down" a list.

-}

{- | A catamorphism turns a list of @b@ into a result of type @c@. -}

data Catamorphism b c =
  Catamorphism
    { start :: c
    , add :: b -> c -> c
    }

{- | Convert an catamorphism to a function. -}

catamorphismFunction :: Catamorphism b c -> ([b] -> c)
catamorphismFunction Catamorphism{..} =
  go
  where
    go =
      \case
        b:bs -> b `add` go bs
        []   -> start

-- |
-- >>> catamorphismFunction productCatamorphism []
-- 1
--
-- >>> catamorphismFunction productCatamorphism [1..4]
-- 24

productCatamorphism :: Num a => Catamorphism a a
productCatamorphism =
  Catamorphism
    { start = 1
    , add = (*)
    }

--------------------------------------------------------------------------------

{- $hylomorphism

"Hylo" and "morphism" are from Greek words meaning "matter" and "form", and the
word "hylomorphism" came about in the 19th century to describe Artistotle's
conception of "being" as a compound of matter and form. This has basically
nothing to do with the hylomorphisms we are discussing here.

-}

{- | A hylomorphism is a combination of an anamorphism (which produces a list of
@b@) with a catamorphism (which consumes the list of @b@). -}

type Hylomorphism a b c =
  (Anamorphism a b, Catamorphism b c)

{- | Convert a hylomorphism to a function by simply applying the anamorphism
function and then the catamorphism function. This approach has an unsatisfying
inefficiency because it involves building an intermediate list of @b@. -}

hylomorphismFunction' :: Hylomorphism a b c -> (a -> c)
hylomorphismFunction' (ana, cata) =
  catamorphismFunction cata . anamorphismFunction ana

{- | Convert a hylomorphism to a function in a more intelligent way, by feeding
each @b@ generated by the anamorphism directly into the 'add' function of the
catamorphism, thus avoiding construction of the intermediate list of @b@. -}

hylomorphismFunction :: Hylomorphism a b c -> (a -> c)
hylomorphismFunction (Anamorphism{..}, Catamorphism{..}) =
  go
  where
    go a =
      case generate a of
        Just (b, a') -> b `add` go a'
        Nothing      -> start

-- |
-- >>> hylomorphismFunction factorialHylomorphism 4
-- 24

factorialHylomorphism :: Hylomorphism Integer Integer Integer
factorialHylomorphism =
  (untilAnamorphism (== 0) (\n -> n - 1), productCatamorphism)

--------------------------------------------------------------------------------

data NumberParamorphism =
  NumberParamorphism
    { start :: Natural
    , step :: Natural -> Natural -> Natural
    }

numberParamorphismFunction :: NumberParamorphism -> (Natural -> Natural)
numberParamorphismFunction NumberParamorphism{..} =
  go
  where
    go =
      \case
        0  -> start
        n' -> let n = n' - 1
              in step n (go n)

-- |
-- >>> numberParamorphismFunction factorialParamorphism 4
-- 24

factorialParamorphism :: NumberParamorphism
factorialParamorphism =
  NumberParamorphism
    { start = 1
    , step = \n m -> (1 + n) * m
    }

--------------------------------------------------------------------------------

data ListParamorphism a =
  ListParamorphism
    { start :: [[a]]
    , step :: a -> ([a], [[a]]) -> [[a]]
    }

listParamorphismFunction :: ListParamorphism a -> ([a] -> [[a]])
listParamorphismFunction ListParamorphism{..} =
  go
  where
    go =
      \case
        []     -> start
        a : as -> step a (as, go as)

-- |
-- >>> listParamorphismFunction tailsParamorphism [1..4]
-- [[1,2,3,4],[2,3,4],[3,4],[4],[]]

tailsParamorphism :: ListParamorphism a
tailsParamorphism =
  ListParamorphism
    { start = [[]]
    , step = \a (as, tls) -> (a : as) : tls
    }
